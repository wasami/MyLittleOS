/*
    Part of the Raspberry-Pi Bare Metal Tutorials
    https://www.valvers.com/rpi/bare-metal/
    Copyright (c) 2013-2018, Brian Sidebotham

    This software is licensed under the MIT License.
    Please see the LICENSE file included with this software.

*/

#include <stdint.h>
#include "../include/rpi-uart.h"
#include "../include/rpi-gpio.h"
#include "../include/fifo.h"

static rpi_aux_t* rpiAux = (rpi_aux_t*)RPI_AUX_BASE;
static rpi_uart_t* rpiMiniUart = (rpi_uart_t*)RPI_UART_BASE;
static fifo_t fifo_buffer;

volatile unsigned int ra;

rpi_aux_t* RPI_GetAux(void)
{
    return rpiAux;
}

rpi_uart_t* RPI_GetMiniUart(void)
{
    return rpiMiniUart;
}

void RPI_MiniUartInit(void)
{
    rpi_uart_t* miniUartReg =  RPI_GetMiniUart();
    rpi_gpio_t* gpioReg = RPI_GetGpio();

    RPI_GetAux()->AUX_ENABLES |= 1;

    miniUartReg->AUX_MU_CNTL_REG = 0;      //Enable mini uart (this also enables access to its registers)
    miniUartReg->AUX_MU_IER_REG = 0;        //Disable receive and transmit interrupts
    miniUartReg->AUX_MU_LCR_REG = 3;        //Enable 8 bit mode
    miniUartReg->AUX_MU_MCR_REG = 0;        //Set RTS line to be always high
    miniUartReg->AUX_MU_BAUD_REG = 270;     //Set baud rate to 115200

    ra = gpioReg->GPFSEL1;
    ra &= ~(7<<12); //gpio14
    ra |= 2<<12;    //alt5
    ra &= ~(7<<15);  // clean gpio15
    ra |= 2<<15;      // set alt5 for gpio 15
    gpioReg->GPFSEL1 = ra;

    //_put32(GPPUD,0);
    gpioReg->GPPUD = 0;
    
    //wait 150 cycles
    for(ra=0;ra<150;ra++);

    //_put32(GPPUDCLK0,(1<<14)|(1<<15));
    gpioReg->GPPUDCLK0 = (1<<14)|(1<<15);

    //wait 150 cycles
    for(ra=0;ra<150;ra++);

    //_put32(GPPUDCLK0,0);
    gpioReg->GPPUDCLK0 = 0;

    /* enable reciever interrupt only */
    miniUartReg->AUX_MU_IER_REG = 2;

    // Setup read and write buffers for mini UART
    fifo_init(&fifo_buffer);

    /* Enable receiver and transmitter */
    miniUartReg->AUX_MU_CNTL_REG = 3;
}

int RPI_WriteToMiniUart(char* string, int nbytes) 
{
    rpi_uart_t* miniUartReg =  RPI_GetMiniUart();

    int i;
    int bytes_written;
    // Staring from index 0; add all characters to buffer
    char* ptr;
    ptr = string;

    bytes_written = 0;

    for( i=0; i<nbytes; i++)
    {
        if( *ptr = '\0' )
        {
            break;
        }
        
        // First check if transmit buffer has enough space
        if (miniUartReg->AUX_MU_LSR_REG & 32)
        {
            miniUartReg->AUX_MU_IO_REG = (uint32_t)*ptr++;     // Write character to transmit buffer
            bytes_written++;
        }
    }

    miniUartReg->AUX_MU_IER_REG |= 1 << 0;      // Enable transmit interrupt

    return bytes_written;
}

int RPI_ReadFromMiniUart(char* data, int nbytes)
{
    return fifo_read(&fifo_buffer, data, nbytes);
}

void RPI_MiniUart_ISR(void) 
{
    rpi_uart_t* miniUartReg =  RPI_GetMiniUart();
    volatile uint32_t incoming_data;
    char incoming_byte;

    // Code executed if Mini UART receiver holds data
    if (miniUartReg->AUX_MU_IIR_REG & 4) 
    {
        incoming_data = miniUartReg->AUX_MU_IO_REG;

        // Echo
        miniUartReg->AUX_MU_IO_REG =  incoming_data;
        miniUartReg->AUX_MU_IER_REG |= 1 << 0;      // Enable transmit interrupt

        // add to buffer
        incoming_byte = incoming_data;

        fifo_write(&fifo_buffer, &incoming_byte, 1);
    }

    // Interupt generated by transmit register being empty
    if (miniUartReg->AUX_MU_IIR_REG & 2) 
    {
        // If transmit register is empty then check if transmit FIFO is empty
        // If transmit FIFO is empty the disable transmit interupt
        // Bit 6 in AUX_MU_LSR_REG is set high if transmit FIFO is empty
        if (miniUartReg->AUX_MU_LSR_REG & 64) 
        {
            miniUartReg->AUX_MU_IER_REG &= ~(1 << 0);      // Disable transmit interrupt
        }
    }
}