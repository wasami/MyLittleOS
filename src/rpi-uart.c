/*
    Part of the Raspberry-Pi Bare Metal Tutorials
    https://www.valvers.com/rpi/bare-metal/
    Copyright (c) 2013-2018, Brian Sidebotham

    This software is licensed under the MIT License.
    Please see the LICENSE file included with this software.

*/

#include <stdint.h>
#include "../include/rpi-uart.h"
#include "../include/rpi-gpio.h"
#include "../include/fifo.h"




// baud rate
//((250,000,000/115200)/8)-1 = 270

static rpi_aux_t* rpiAux = (rpi_aux_t*)RPI_AUX_BASE;
static rpi_uart_t* rpiMiniUart = (rpi_uart_t*)RPI_UART_BASE;
static fifo_t fifo_buffer;

rpi_aux_t* RPI_GetAux(void)
{
    return rpiAux;
}

rpi_uart_t* RPI_GetMiniUart(void)
{
    return rpiMiniUart;
}

void RPI_MiniUartInit(void)
{
    volatile int i;

    rpi_gpio_t* gpioReg = RPI_GetGpio();

    rpiAux->AUX_ENABLES |= 1;               // Enable mini uart (this also enables access to its registers)

    rpiMiniUart->AUX_MU_IER_REG = 0;                        // Disable receive and transmit interrupts
    rpiMiniUart->AUX_MU_CNTL_REG = 0;                       // Disable flow control
    rpiMiniUart->AUX_MU_LCR_REG = AUX_MULCR_8BIT_MODE;      // Enable 8 bit mode
    rpiMiniUart->AUX_MU_MCR_REG = 0;                        // Set RTS line to be always high
    rpiMiniUart->AUX_MU_IIR_REG = AUX_MUCNTL_CLEAR_FIFO;    // Clear FIFOs 

    rpiMiniUart->AUX_MU_BAUD_REG = AUX_MU_BAUD_RATE;        // Set baud rate to 115200

    /* Setup GPIO 14 and 15 as alternative function 5 which is
        UART 1 TXD/RXD. These need to be set before enabling the UART */
    RPI_SetGpioPinFunction( RPI_GPIO14, FS_ALT5 );
    RPI_SetGpioPinFunction( RPI_GPIO15, FS_ALT5 );

    gpioReg->GPPUD = 0;
    for(i=0;i<150;i++) {}     //wait 150 cycles
    gpioReg->GPPUDCLK0 = (1<<14)|(1<<15);
    for(i=0;i<150;i++) {}     //wait 150 cycles
    gpioReg->GPPUDCLK0 = 0;

    /* enable reciever interrupt only */
    // rpiMiniUart->AUX_MU_IER_REG = 2;

    // Setup read and write buffers for mini UART
    // fifo_init(&fifo_buffer);

    /* Enable receiver and transmitter */
    rpiMiniUart->AUX_MU_CNTL_REG = 3;
}

void RPI_WriteToMiniUart( char c )
{
    /* Wait until the UART has an empty space in the FIFO */
    while( ( rpiMiniUart->AUX_MU_LSR_REG & AUX_MULSR_TX_EMPTY ) == 0 ) { }

    /* Write the character to the FIFO for transmission */
    rpiMiniUart->AUX_MU_IO_REG = c;
}

int RPI_printStringOfLen( char* string, int len )
{
    int i;

    for( i=0; i < len; i++)
        RPI_WriteToMiniUart( *string++ );

    return len;
}

void RPI_printString( char* string)
{
    while( *string != '\0')
    {
        RPI_WriteToMiniUart( *string++ );
    }
}


int RPI_ReadFromMiniUart(char* data, int nbytes)
{
    return fifo_read(&fifo_buffer, data, nbytes);
}

void RPI_MiniUart_ISR(void) 
{
    volatile uint32_t incoming_data;
    char incoming_byte;

    // Code executed if Mini UART receiver holds data
    if (rpiMiniUart->AUX_MU_IIR_REG & 4) 
    {
        incoming_data = rpiMiniUart->AUX_MU_IO_REG;

        // Echo
        rpiMiniUart->AUX_MU_IO_REG =  incoming_data;
        rpiMiniUart->AUX_MU_IER_REG |= 1 << 0;      // Enable transmit interrupt

        // add to buffer
        incoming_byte = incoming_data;

        fifo_write(&fifo_buffer, &incoming_byte, 1);
    }

    // Interupt generated by transmit register being empty
    if (rpiMiniUart->AUX_MU_IIR_REG & 2) 
    {
        // If transmit register is empty then check if transmit FIFO is empty
        // If transmit FIFO is empty the disable transmit interupt
        // Bit 6 in AUX_MU_LSR_REG is set high if transmit FIFO is empty
        if (rpiMiniUart->AUX_MU_LSR_REG & 64) 
        {
            rpiMiniUart->AUX_MU_IER_REG &= ~(1 << 0);      // Disable transmit interrupt
        }
    }
}