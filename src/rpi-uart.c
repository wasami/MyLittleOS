/*
    Part of the Raspberry-Pi Bare Metal Tutorials
    https://www.valvers.com/rpi/bare-metal/
    Copyright (c) 2013-2018, Brian Sidebotham

    This software is licensed under the MIT License.
    Please see the LICENSE file included with this software.

*/

#include <stdint.h>
#include "../include/rpi-uart.h"
#include "../include/rpi-gpio.h"
#include "../include/fifo.h"

//GPIO14  TXD0 and TXD1
//GPIO15  RXD0 and RXD1
//alt function 5 for uart1
//alt function 0 for uart0

// baud rate
//((250,000,000/115200)/8)-1 = 270

static rpi_aux_t* rpiAux = (rpi_aux_t*)RPI_AUX_BASE;
static rpi_uart_t* rpiMiniUart = (rpi_uart_t*)RPI_UART_BASE;
static fifo_t fifo_buffer;

rpi_aux_t* RPI_GetAux(void)
{
    return rpiAux;
}

rpi_uart_t* RPI_GetMiniUart(void)
{
    return rpiMiniUart;
}

void RPI_MiniUartInit(void)
{
    volatile int i;

    rpi_gpio_t* gpioReg = RPI_GetGpio();

    rpiAux->AUX_ENABLES |= 1;

    rpiMiniUart->AUX_MU_CNTL_REG = 0;      //Enable mini uart (this also enables access to its registers)
    rpiMiniUart->AUX_MU_IER_REG = 0;        //Disable receive and transmit interrupts
    rpiMiniUart->AUX_MU_LCR_REG = 1;        //Enable 8 bit mode
    rpiMiniUart->AUX_MU_MCR_REG = 0;        //Set RTS line to be always high
    rpiMiniUart->AUX_MU_BAUD_REG = 270;     //Set baud rate to 115200

    i = gpioReg->GPFSEL1;
    i &= ~(7<<12);      //gpio14
    i |= 2<<12;         //alt5
    i &= ~(7<<15);      // clean gpio15
    i |= 2<<15;         // set alt5 for gpio 15
    gpioReg->GPFSEL1 = i;

    //_put32(GPPUD,0);
    gpioReg->GPPUD = 0;
    
    //wait 150 cycles
    for(i=0;i<150;i++);

    //_put32(GPPUDCLK0,(1<<14)|(1<<15));
    gpioReg->GPPUDCLK0 = (1<<14)|(1<<15);

    //wait 150 cycles
    for(i=0;i<150;i++);

    //_put32(GPPUDCLK0,0);
    gpioReg->GPPUDCLK0 = 0;

    /* enable reciever interrupt only */
    rpiMiniUart->AUX_MU_IER_REG = 2;

    // Setup read and write buffers for mini UART
    fifo_init(&fifo_buffer);

    /* Enable receiver and transmitter */
    rpiMiniUart->AUX_MU_CNTL_REG = 3;
}

void RPI_WriteToMiniUart( char c )
{
    /* Wait until the UART has an empty space in the FIFO */
    while( ( rpiMiniUart->AUX_MU_LSR_REG & AUX_MULSR_TX_EMPTY ) == 0 ) { }

    /* Write the character to the FIFO for transmission */
    rpiMiniUart->AUX_MU_IO_REG = c;
}

int RPI_printString( char* string, int len )
{
    int i;

    for( i=0; i < len; i++)
        RPI_WriteToMiniUart( *string++ );

    return len;
}


int RPI_ReadFromMiniUart(char* data, int nbytes)
{
    return fifo_read(&fifo_buffer, data, nbytes);
}

void RPI_MiniUart_ISR(void) 
{
    volatile uint32_t incoming_data;
    char incoming_byte;

    // Code executed if Mini UART receiver holds data
    if (rpiMiniUart->AUX_MU_IIR_REG & 4) 
    {
        incoming_data = rpiMiniUart->AUX_MU_IO_REG;

        // Echo
        rpiMiniUart->AUX_MU_IO_REG =  incoming_data;
        rpiMiniUart->AUX_MU_IER_REG |= 1 << 0;      // Enable transmit interrupt

        // add to buffer
        incoming_byte = incoming_data;

        fifo_write(&fifo_buffer, &incoming_byte, 1);
    }

    // Interupt generated by transmit register being empty
    if (rpiMiniUart->AUX_MU_IIR_REG & 2) 
    {
        // If transmit register is empty then check if transmit FIFO is empty
        // If transmit FIFO is empty the disable transmit interupt
        // Bit 6 in AUX_MU_LSR_REG is set high if transmit FIFO is empty
        if (rpiMiniUart->AUX_MU_LSR_REG & 64) 
        {
            rpiMiniUart->AUX_MU_IER_REG &= ~(1 << 0);      // Disable transmit interrupt
        }
    }
}